<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Bloom filters, using bit arrays for recommendations, caches and Bitcoin | Bart de Goede</title><meta name=keywords content="python,bloom filter"><meta name=description content="Bloom filters are cool. In my experience, it&rsquo;s a somewhat underestimated data structure that sounds more complex than it actually is. In this post I&rsquo;ll go over what they are, how they work (I&rsquo;ve hacked together an interactive example to help visualise what happens behind the scenes) and go over some of their usecases in the wild."><meta name=author content="Bart de Goede"><link rel=canonical href=https://bart.degoe.de/bloom-filters-bit-arrays-recommendations-caches-bitcoin/><link crossorigin=anonymous href=/assets/css/stylesheet.aa7fa40e4383c927e89501a480a6bdc90ae0256399320eff08bd92f128233bc6.css integrity="sha256-qn+kDkODySfolQGkgKa9yQrgJWOZMg7/CL2S8SgjO8Y=" rel="preload stylesheet" as=style><link rel=icon href=https://bart.degoe.de/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://bart.degoe.de/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://bart.degoe.de/favicon-32x32.png><link rel=apple-touch-icon href=https://bart.degoe.de/apple-touch-icon.png><link rel=mask-icon href=https://bart.degoe.de/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=https://bart.degoe.de/bloom-filters-bit-arrays-recommendations-caches-bitcoin/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><link rel=search href=/opensearch.xml type=application/opensearchdescription+xml title="Search bart.degoe.de"><script src=/js/posts/2018-03-22-bloom-filters-bit-arrays-recommendations-caches-bitcoin/murmurhash3js.min.js></script><script src=/js/posts/2018-03-22-bloom-filters-bit-arrays-recommendations-caches-bitcoin/bloomfilters.js></script><script async src="https://www.googletagmanager.com/gtag/js?id=G-6JBRP5YVDB"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-6JBRP5YVDB")}</script><meta property="og:url" content="https://bart.degoe.de/bloom-filters-bit-arrays-recommendations-caches-bitcoin/"><meta property="og:site_name" content="Bart de Goede"><meta property="og:title" content="Bloom filters, using bit arrays for recommendations, caches and Bitcoin"><meta property="og:description" content="Bloom filters are cool. In my experience, it’s a somewhat underestimated data structure that sounds more complex than it actually is. In this post I’ll go over what they are, how they work (I’ve hacked together an interactive example to help visualise what happens behind the scenes) and go over some of their usecases in the wild."><meta property="og:locale" content="en-us"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-03-23T15:00:00+01:00"><meta property="article:modified_time" content="2018-03-23T15:00:00+01:00"><meta property="og:image" content="https://www.gravatar.com/avatar/af61db828941976309aaa8d7d76554fb"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://www.gravatar.com/avatar/af61db828941976309aaa8d7d76554fb"><meta name=twitter:title content="Bloom filters, using bit arrays for recommendations, caches and Bitcoin"><meta name=twitter:description content="Bloom filters are cool. In my experience, it&rsquo;s a somewhat underestimated data structure that sounds more complex than it actually is. In this post I&rsquo;ll go over what they are, how they work (I&rsquo;ve hacked together an interactive example to help visualise what happens behind the scenes) and go over some of their usecases in the wild."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://bart.degoe.de/post/"},{"@type":"ListItem","position":2,"name":"Bloom filters, using bit arrays for recommendations, caches and Bitcoin","item":"https://bart.degoe.de/bloom-filters-bit-arrays-recommendations-caches-bitcoin/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Bloom filters, using bit arrays for recommendations, caches and Bitcoin","name":"Bloom filters, using bit arrays for recommendations, caches and Bitcoin","description":"Bloom filters are cool. In my experience, it\u0026rsquo;s a somewhat underestimated data structure that sounds more complex than it actually is. In this post I\u0026rsquo;ll go over what they are, how they work (I\u0026rsquo;ve hacked together an interactive example to help visualise what happens behind the scenes) and go over some of their usecases in the wild.\n","keywords":["python","bloom filter"],"articleBody":"Bloom filters are cool. In my experience, it’s a somewhat underestimated data structure that sounds more complex than it actually is. In this post I’ll go over what they are, how they work (I’ve hacked together an interactive example to help visualise what happens behind the scenes) and go over some of their usecases in the wild.\nListen to this article instead Your browser does not support the audio element What is a Bloom filter? A Bloom filter is a data structure designed to quickly tell you whether an element is not in a set. What’s even nicer, it does so within the memory constraints you specify. It doesn’t actually store the data itself, only trimmed down version of it. This gives it the desirable property that it has a constant time complexity1 for both adding a value to the filter and for checking whether a value is present in the filter. The cool part is that this is independent of how many elements already in the filter.\nLike with most things that offer great benefits, there is a trade-off: Bloom filters are probabilistic in nature. On rare occassions, it will respond with yes to the question if the element is in the set (false positives are a possibility), although it will never respond with no if the value is actually present (false negatives can’t happen).\nYou can actually control how rare those occassions are, by setting the size of the Bloom filter bit array and the amount of hash functions depending on the amount of elements you expect to add2. Also, note that you can’t remove items from a Bloom filter.\nHow does it work? An empty Bloom filter is a bit array of a particular size (let’s call that size m) where all the bits are set to 0. In addition, there must be a number (let’s call the number k) of hashing functions defined. Each of these functions hashes a value to one of the positions in our array m, distributing the values uniformly over the array.\nWe’ll do a very simple Python implementation3 of a Bloom filter. For simplicity’s sake, we’ll use a bit array4 with 15 bits (m=15) and 3 hashing functions (k=3) for the running example.\nimport mmh3 class Bloomfilter(object): def __init__(self, m=15, k=3): self.m = m self.k = k # we use a list of Booleans to represent our # bit array for simplicity self.bit_array = [False for i in range(self.m)] def add(self, element): ... def check(self, element): ... To add elements to the array, our add method needs to run k hashing functions on the input that each will almost randomly pick an index in our bit array. We’ll use the mmh3 library to hash our element, and use the amount of hash functions we want to apply as a seed to give us different hashes for each of them. Finally, we compute the remainder of the hash divided by the size of the bit array to obtain the position we want to set.5\ndef add(self, element): \"\"\" Add an element to the filter. Murmurhash3 gives us hash values distributed uniformly enough we can use different seeds to represent different hash functions \"\"\" for i in range(self.k): # this will give us a number between 0 and m - 1 digest = mmh3.hash(element, i, signed=False) % self.m self.bit_array[digest] = True In our case (m=15 and k=3), we would set the bits at index 1, 7 and 10 to one for the string hello.\nIn [1]: mmh3.hash('hello', 0, signed=False) % 15 Out[1]: 1 In [2]: mmh3.hash('hello', 1, signed=False) % 15 Out[2]: 7 In [3]: mmh3.hash('hello', 2, signed=False) % 15 Out[3]: 10 Now, to determine if an element is in the bloom filter, we apply the same hash functions to the element, and see whether the bits at the resulting indices are all 1. If one of them is not 1, then the element has not been added to the filter (because otherwise we’d see a value of 1 for all hash functions!).\ndef check(self, element): \"\"\" To check whether element is in the filter, we hash the element with the same hash functions as the add functions (using the seed). If one of them doesn't occur in our bit_array, the element is not in there (only a value that hashes to all of the same indices we've already seen before). \"\"\" for i in range(self.k): digest = mmh3.hash(element, i, signed=False) % self.m if self.bit_array[digest] == False: # if any of the bits hasn't been set, then it's not in # the filter return False return True You can see how this approach guarantuees that there will be no false negatives, but that there might be false positives; especially in our toy example with the small bit array, the more elements you add to the filter, the more likely it gets that the three bits we hash an element to are set other elements (running one of the hash functions on the string world will also set the bit at index 6 to 1):\nIn [4]: mmh3.hash('world', 0, signed=False) % 15 Out[4]: 7 In [5]: mmh3.hash('world', 1, signed=False) % 15 Out[5]: 4 In [6]: mmh3.hash('world', 2, signed=False) % 15 Out[6]: 9 We can actually compute the probability of our Bloom filter returning a false positive, as it is a function of the number of bits used in the bit array divided by the length of the bit array (m) to the power of hash functions we’re using k (we’ll leave that for a future post though). The more values we add, the higher the probability of false positives becomes.\nInteractive example To further drive home how Bloom filters work, I’ve hacked together a Bloom filter in JavaScript that uses the cells in the table below as a “bit array” to visualise how adding more values will fill up the filter and increase the probability of a false positive (a full Bloom filter will always return “yes” for whatever value you throw at it).\nAdd Hash value 1: Hash value 2: Hash value 3: Elements in the filter: []\nProbability of false positives: 0% Test In Bloom filter: What can I use it for? Given that a Bloom filter is really good at telling you whether something is in a set or not, caching is a prime candidate for using a Bloom filter. CDN providers like Akamai6 use it to optimise their disk caches; nearly 75% of the URLs that are accessed in their web caches is accessed only once and then never again. To prevent caching these “one-hit wonders” and massively saving disk space requirements, Akamai uses a Bloom filter to store all URLs that are accessed. If a URL is found in the Bloom filter, it means it was requested before, and should be stored in their disk cache.\nBlogging platform Medium uses Bloom filters7 to filter out posts that users have already read from their personalised reading lists. They create a Bloom filter for every user, and add every article they read to the filter. When a reading list is generated, they can check the filter whether the user has seen the article. The trade-off for false positives (i.e. an article they haven’t read before) is more than acceptable, because in that case the user won’t be shown an article that they haven’t read yet (so they will never know).\nQuora does something similar to filter out stories users have seen before, and Facebook and LinkedIn use Bloom filters in their typeahead searches (it basically provides a fast and memory-efficient way to filter out documents that can’t match on the prefix of the query terms).\nBitcoin relies strongly on a peer-to-peer style of communication, instead of a client-server architecture in the examples above. Every node in the network is a server, and everyone in the network has a copy of everone else’s transactions. For big beefy servers in a data center that’s fine, but what if you don’t necessarily care about all transactions? Think of a mobile wallet application for example, you don’t want all transactions on the blockchain, especially when you have to download them on a mobile connection. To address this, Bitcoin has an option called Simplified Payment Verification (SPV) which lets your (mobile) node request only the transactions it’s interested in (i.e. payments from or to your wallet address). The SPV client calculates a Bloom filter for the transactions it cares about, so the “full node” has an efficient way to answer “is this client interested in this transation?”. The cost of false positives (i.e. a client is actually not interested in a transaction) is minimal, because when the client processes the transactions returned by the full node it can simply discard the ones it doesn’t care about.\nClosing thoughts There are a lot more applications for Bloom filters out there, and I can’t list them all here. I hope a gave you a whirlwind overview of how Bloom filters work and how they might be useful to you.\nFeel free to drop me a line or comment below if you have nice examples of where they’re used, or if you have any feedback, comments, or just want to say hi :-)\nThe runtime for both inserting and checking is defined by the number of hash functions (k) we have to execute. So, O(k). Space complexity is more difficult to quantify, because that depends on how many false positives you’re willing to tolerate; allocating more space will lower the false positive rate. ↩︎\nGoing over the math is a bit much for this post, so check Wikipedia for all the formulas 😄. ↩︎\nFull implementation on GitHub. ↩︎\nOur implementation won’t use an actual bit array but a Python list containing Booleans for the sake of readability. ↩︎\nNote that there’s a slight difference between the Python and Javascript Murmurhash implementation in the libraries I’ve used; the Javascript library I used returns a 32 bit unsigned integer, where the Python library returns a 32 bit signed integer by default. To keep the Python example consistent with the Javascript, I opted to use unsigned integers there too; there is no impact for the working of the Bloom filter. ↩︎\nMaggs, Bruce M.; Sitaraman, Ramesh K. (July 2015), “Algorithmic nuggets in content delivery”, SIGCOMM Computer Communication Review, New York, NY, USA: ACM, 45 (3): 52–66, doi:10.1145/2805789.2805800 ↩︎\nRead the article. It’s really good. ↩︎\n","wordCount":"1726","inLanguage":"en","image":"https://www.gravatar.com/avatar/af61db828941976309aaa8d7d76554fb","datePublished":"2018-03-23T15:00:00+01:00","dateModified":"2018-03-23T15:00:00+01:00","author":{"@type":"Person","name":"Bart de Goede"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://bart.degoe.de/bloom-filters-bit-arrays-recommendations-caches-bitcoin/"},"publisher":{"@type":"Organization","name":"Bart de Goede","logo":{"@type":"ImageObject","url":"https://bart.degoe.de/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://bart.degoe.de/ accesskey=h title="Bart de Goede (Alt + H)">Bart de Goede</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://bart.degoe.de/about/ title=About><span>About</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://bart.degoe.de/>Home</a>&nbsp;»&nbsp;<a href=https://bart.degoe.de/post/>Posts</a></div><h1 class="post-title entry-hint-parent">Bloom filters, using bit arrays for recommendations, caches and Bitcoin</h1><div class=post-meta><span title='2018-03-23 15:00:00 +0100 +0100'>March 23, 2018</span>&nbsp;·&nbsp;<span>9 min</span>&nbsp;·&nbsp;<span>Bart de Goede</span></div></header><div class=post-content><p>Bloom filters are cool. In my experience, it&rsquo;s a somewhat underestimated data structure that sounds more complex than it actually is. In this post I&rsquo;ll go over what they are, how they work (I&rsquo;ve hacked together an <a href=#interactive_example>interactive example</a> to help visualise what happens behind the scenes) and go over some of their usecases in the wild.</p><div id=player><div class=listen>Listen to this article instead</div><div id=waveform><img src=https://bart.degoe.de/img/waveform.min.svg alt=waveform></div><audio controls class=audio_controls preload=metadata><source src=/audio/2018-03-22-bloom-filters-bit-arrays-recommendations-caches-bitcoin.mp3 type=audio/mp3>Your browser does not support the audio element</audio></div><h1 id=what-is-a-bloom-filter>What is a Bloom filter?<a hidden class=anchor aria-hidden=true href=#what-is-a-bloom-filter>#</a></h1><p>A Bloom filter is a data structure designed to quickly tell you whether an element is not in a set. What&rsquo;s even nicer, it does so within the memory constraints you specify. It doesn&rsquo;t actually store the data itself, only trimmed down version of it. This gives it the desirable property that it has a <em>constant time complexity</em><sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup> for both adding a value to the filter <em>and</em> for checking whether a value is present in the filter. The cool part is that this is <em>independent</em> of how many elements already in the filter.</p><p>Like with most things that offer great benefits, there is a trade-off: Bloom filters are probabilistic in nature. On rare occassions, it will respond with <em>yes</em> to the question if the element is in the set (<em>false positives</em> are a possibility), although it will never respond with <em>no</em> if the value is actually present (<em>false negatives</em> can&rsquo;t happen).</p><p>You can actually control how rare those occassions are, by setting the size of the Bloom filter bit array and the amount of hash functions depending on the amount of elements you expect to add<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>. Also, note that you can&rsquo;t remove items from a Bloom filter.</p><h1 id=how-does-it-work>How does it work?<a hidden class=anchor aria-hidden=true href=#how-does-it-work>#</a></h1><p>An empty Bloom filter is a bit array of a particular size (let&rsquo;s call that size <em>m</em>) where all the bits are set to 0. In addition, there must be a number (let&rsquo;s call the number <em>k</em>) of hashing functions defined. Each of these functions hashes a value to one of the positions in our array <em>m</em>, distributing the values uniformly over the array.</p><p>We&rsquo;ll do a very simple Python implementation<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> of a Bloom filter. For simplicity&rsquo;s sake, we&rsquo;ll use a bit array<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> with 15 bits (<code>m=15</code>) and 3 hashing functions (<code>k=3</code>) for the running example.</p><pre tabindex=0><code>import mmh3

class Bloomfilter(object):
    def __init__(self, m=15, k=3):
        self.m = m
        self.k = k
        # we use a list of Booleans to represent our
        # bit array for simplicity
        self.bit_array = [False for i in range(self.m)]

    def add(self, element):
        ...

    def check(self, element):
        ...
</code></pre><p>To add elements to the array, our <code>add</code> method needs to run <code>k</code> hashing functions on the input that each will almost randomly pick an index in our bit array. We&rsquo;ll use the <a href=https://pypi.python.org/pypi/mmh3><code>mmh3</code></a> library to hash our <code>element</code>, and use the amount of hash functions we want to apply as a seed to give us different hashes for each of them. Finally, we compute the remainder of the hash divided by the size of the bit array to obtain the position we want to set.<sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p><pre tabindex=0><code>def add(self, element):
    &#34;&#34;&#34;
    Add an element to the filter. Murmurhash3 gives us hash values
    distributed uniformly enough we can use different seeds to
    represent different hash functions
    &#34;&#34;&#34;
    for i in range(self.k):
        # this will give us a number between 0 and m - 1
        digest = mmh3.hash(element, i, signed=False) % self.m
        self.bit_array[digest] = True
</code></pre><p>In our case (<code>m=15</code> and <code>k=3</code>), we would set the bits at index 1, 7 and 10 to one for the string <code>hello</code>.</p><pre tabindex=0><code>In [1]: mmh3.hash(&#39;hello&#39;, 0, signed=False) % 15
Out[1]: 1

In [2]: mmh3.hash(&#39;hello&#39;, 1, signed=False) % 15
Out[2]: 7

In [3]: mmh3.hash(&#39;hello&#39;, 2, signed=False) % 15
Out[3]: 10
</code></pre><p>Now, to determine if an element is in the bloom filter, we apply the same hash functions to the element, and see whether the bits at the resulting indices are all 1. If one of them is <em>not</em> 1, then the element has not been added to the filter (because otherwise we&rsquo;d see a value of 1 for all hash functions!).</p><pre tabindex=0><code>def check(self, element):
    &#34;&#34;&#34;
    To check whether element is in the filter, we hash the element with
    the same hash functions as the add functions (using the seed). If one
    of them doesn&#39;t occur in our bit_array, the element is not in there
    (only a value that hashes to all of the same indices we&#39;ve already
    seen before).
    &#34;&#34;&#34;
    for i in range(self.k):
        digest = mmh3.hash(element, i, signed=False) % self.m
        if self.bit_array[digest] == False:
            # if any of the bits hasn&#39;t been set, then it&#39;s not in
            # the filter
            return False
    return True
</code></pre><p>You can see how this approach guarantuees that there will be no <em>false negatives</em>, but that there might be <em>false positives</em>; especially in our toy example with the small bit array, the more elements you add to the filter, the more likely it gets that the three bits we hash an element to are set other elements (running one of the hash functions on the string <code>world</code> will also set the bit at index 6 to 1):</p><pre tabindex=0><code>In [4]: mmh3.hash(&#39;world&#39;, 0, signed=False) % 15
Out[4]: 7

In [5]: mmh3.hash(&#39;world&#39;, 1, signed=False) % 15
Out[5]: 4

In [6]: mmh3.hash(&#39;world&#39;, 2, signed=False) % 15
Out[6]: 9
</code></pre><p>We can actually <a href=https://en.wikipedia.org/wiki/Bloom_filter#Probability_of_false_positives>compute the probability</a> of our Bloom filter returning a false positive, as it is a function of the number of bits used in the bit array divided by the length of the bit array (<code>m</code>) to the power of hash functions we&rsquo;re using <code>k</code> (we&rsquo;ll leave that for a future post though). The more values we add, the higher the probability of false positives becomes.</p><h1 id=interactive-example><a name=interactive_example></a>Interactive example<a hidden class=anchor aria-hidden=true href=#interactive-example>#</a></h1><p>To further drive home how Bloom filters work, I&rsquo;ve hacked together a Bloom filter in JavaScript that uses the cells in the table below as a &ldquo;bit array&rdquo; to visualise how adding more values will fill up the filter and increase the probability of a false positive (a full Bloom filter will always return &ldquo;yes&rdquo; for whatever value you throw at it).</p><table id=bitvector border=1><tbody><tr id=bits></tr><tr id=labels></tr></tbody></table><div class=input-container><input placeholder="Add an element" id=bloom_input class=input aria-label="Add an element to the bloom filter">
<button id=add_value_to_bloom_filter>Add</button></div><div id=hashes><b>Hash value 1:</b> <span id=hash0></span><br><b>Hash value 2:</b> <span id=hash1></span><br><b>Hash value 3:</b> <span id=hash2></span><br><br><b>Elements in the filter:</b> [<span id=elements></span>]<br><b>Probability of false positives:</b> <span id=false_positive_probability>0%</span></div><div class=input-container><input placeholder="Element in filter?" id=bloom_input_test class=input aria-label="Does the filter contain the element">
<button id=test_value_in_bloom_filter>Test</button></div><div id=in_bloom_filter><b>In Bloom filter:</b> <span></span></div><hr><h1 id=what-can-i-use-it-for>What can I use it for?<a hidden class=anchor aria-hidden=true href=#what-can-i-use-it-for>#</a></h1><p>Given that a Bloom filter is really good at telling you whether something is in a set or not, caching is a prime candidate for using a Bloom filter. CDN providers like Akamai<sup id=fnref:6><a href=#fn:6 class=footnote-ref role=doc-noteref>6</a></sup> use it to optimise their disk caches; nearly 75% of the URLs that are accessed in their web caches is accessed only once and then never again. To prevent caching these &ldquo;one-hit wonders&rdquo; and massively saving disk space requirements, Akamai uses a Bloom filter to store all URLs that are accessed. If a URL is found in the Bloom filter, it means it was requested before, and should be stored in their disk cache.</p><p>Blogging platform Medium <a href=https://blog.medium.com/what-are-bloom-filters-1ec2a50c68ff>uses Bloom filters</a><sup id=fnref:7><a href=#fn:7 class=footnote-ref role=doc-noteref>7</a></sup> to filter out posts that users have already read from their personalised reading lists. They create a Bloom filter for every user, and add every article they read to the filter. When a reading list is generated, they can check the filter whether the user has seen the article. The trade-off for false positives (i.e. an article they <em>haven&rsquo;t</em> read before) is more than acceptable, because in that case the user won&rsquo;t be shown an article that they haven&rsquo;t read yet (so they will never know).</p><p>Quora does something similar to filter out stories users have seen before, and <a href=https://www.facebook.com/Engineering/videos/432864835468/>Facebook</a> and <a href=https://engineering.linkedin.com/open-source/cleo-open-source-technology-behind-linkedins-typeahead-search>LinkedIn</a> use Bloom filters in their typeahead searches (it basically provides a fast and memory-efficient way to filter out documents that can&rsquo;t match on the prefix of the query terms).</p><p>Bitcoin relies strongly on a peer-to-peer style of communication, instead of a client-server architecture in the examples above. Every node in the network is a server, and everyone in the network has a copy of everone else&rsquo;s transactions. For big beefy servers in a data center that&rsquo;s fine, but what if you don&rsquo;t necessarily care about <em>all</em> transactions? Think of a mobile wallet application for example, you don&rsquo;t want all transactions on the blockchain, especially when you have to download them on a mobile connection. To address this, Bitcoin has an option called <a href=https://en.bitcoin.it/wiki/Scalability#Simplified_payment_verification>Simplified Payment Verification</a> (SPV) which lets your (mobile) node request only the transactions it&rsquo;s interested in (i.e. payments from or to your wallet address). The SPV client calculates a Bloom filter for the transactions it cares about, so the &ldquo;full node&rdquo; has an efficient way to answer &ldquo;is this client interested in this transation?&rdquo;. The cost of false positives (i.e. a client is actually <em>not</em> interested in a transaction) is minimal, because when the client processes the transactions returned by the full node it can simply discard the ones it doesn&rsquo;t care about.</p><h1 id=closing-thoughts>Closing thoughts<a hidden class=anchor aria-hidden=true href=#closing-thoughts>#</a></h1><p>There are <a href=https://www.quora.com/What-are-the-best-applications-of-Bloom-filters>a lot more applications</a> for Bloom filters out there, and I can&rsquo;t list them all here. I hope a gave you a whirlwind overview of how Bloom filters work and how they might be useful to you.</p><p>Feel free to <a href=/about/>drop me a line</a> or comment below if you have nice examples of where they&rsquo;re used, or if you have any feedback, comments, or just want to say hi :-)</p><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>The runtime for both inserting and checking is defined by the number of hash functions (<code>k</code>) we have to execute. So, <code>O(k)</code>. Space complexity is more difficult to quantify, because that depends on how many false positives you&rsquo;re willing to tolerate; allocating more space will lower the false positive rate.&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Going over the math is a bit much for this post, so check <a href=https://en.wikipedia.org/wiki/Bloom_filter#Optimal_number_of_hash_functions>Wikipedia</a> for all the formulas 😄.&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>Full implementation on <a href=https://gist.github.com/bartdegoede/42ef7a265d946a9a75617a89ecbaf674>GitHub</a>.&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>Our implementation won&rsquo;t use an actual bit array but a Python list containing Booleans for the sake of readability.&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>Note that there&rsquo;s a slight difference between the Python and Javascript Murmurhash implementation in the libraries I&rsquo;ve used; the <a href=https://pid.github.io/murmurHash3js/>Javascript library I used</a> returns a 32 bit <em>unsigned</em> integer, where the <a href=https://github.com/hajimes/mmh3>Python library</a> returns a 32 bit <em>signed</em> integer by default. To keep the Python example consistent with the Javascript, I opted to use unsigned integers there too; there is no impact for the working of the Bloom filter.&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:6><p>Maggs, Bruce M.; Sitaraman, Ramesh K. (July 2015), &ldquo;Algorithmic nuggets in content delivery&rdquo;, <em>SIGCOMM Computer Communication Review</em>, New York, NY, USA: ACM, 45 (3): 52–66, <a href=https://doi.org/10.1145%2F2805789.2805800><code>doi:10.1145/2805789.2805800</code></a>&#160;<a href=#fnref:6 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:7><p>Read the article. It&rsquo;s really good.&#160;<a href=#fnref:7 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><div style="margin:2rem 0;text-align:center"><style>.bmc-button img{width:27px !important;margin-bottom:1px !important;box-shadow:none !important;border:none !important;vertical-align:middle !important}.bmc-button{line-height:36px !important;height:37px !important;text-decoration:none !important;display:inline-flex !important;color:#000 !important;background-color:#fff !important;border-radius:3px !important;border:1px solid transparent !important;padding:0 9px !important;font-size:17px !important;letter-spacing:-.08px !important;box-shadow:0 1px 2px rgba(190,190,190,.5) !important;-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5) !important;margin:0 auto !important;font-family:lato,sans-serif !important;-webkit-box-sizing:border-box !important;box-sizing:border-box !important;-o-transition:.3s all linear !important;-webkit-transition:.3s all linear !important;-moz-transition:.3s all linear !important;-ms-transition:.3s all linear !important;transition:.3s all linear !important}.bmc-button:hover,.bmc-button:active,.bmc-button:focus{-webkit-box-shadow:0 1px 2px 2px rgba(190,190,190,.5) !important;text-decoration:none !important;box-shadow:0 1px 2px 2px rgba(190,190,190,.5) !important;opacity:.85 !important;color:#000 !important}</style><link href="https://fonts.googleapis.com/css?family=Lato&subset=latin,latin-ext&display=swap" rel=stylesheet><a class=bmc-button target=_blank href=https://www.buymeacoffee.com/bart><img src=https://www.buymeacoffee.com/assets/img/BMC-btn-logo.svg alt="Buy me a coffee!">
<span style=margin-left:5px>Buy me a coffee!</span></a></div><footer class=post-footer><ul class=post-tags></ul><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, using bit arrays for recommendations, caches and Bitcoin on x" href="https://x.com/intent/tweet/?text=Bloom%20filters%2c%20using%20bit%20arrays%20for%20recommendations%2c%20caches%20and%20Bitcoin&amp;url=https%3a%2f%2fbart.degoe.de%2fbloom-filters-bit-arrays-recommendations-caches-bitcoin%2f&amp;hashtags="><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, using bit arrays for recommendations, caches and Bitcoin on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fbart.degoe.de%2fbloom-filters-bit-arrays-recommendations-caches-bitcoin%2f&amp;title=Bloom%20filters%2c%20using%20bit%20arrays%20for%20recommendations%2c%20caches%20and%20Bitcoin&amp;summary=Bloom%20filters%2c%20using%20bit%20arrays%20for%20recommendations%2c%20caches%20and%20Bitcoin&amp;source=https%3a%2f%2fbart.degoe.de%2fbloom-filters-bit-arrays-recommendations-caches-bitcoin%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, using bit arrays for recommendations, caches and Bitcoin on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fbart.degoe.de%2fbloom-filters-bit-arrays-recommendations-caches-bitcoin%2f&title=Bloom%20filters%2c%20using%20bit%20arrays%20for%20recommendations%2c%20caches%20and%20Bitcoin"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, using bit arrays for recommendations, caches and Bitcoin on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fbart.degoe.de%2fbloom-filters-bit-arrays-recommendations-caches-bitcoin%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, using bit arrays for recommendations, caches and Bitcoin on whatsapp" href="https://api.whatsapp.com/send?text=Bloom%20filters%2c%20using%20bit%20arrays%20for%20recommendations%2c%20caches%20and%20Bitcoin%20-%20https%3a%2f%2fbart.degoe.de%2fbloom-filters-bit-arrays-recommendations-caches-bitcoin%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, using bit arrays for recommendations, caches and Bitcoin on telegram" href="https://telegram.me/share/url?text=Bloom%20filters%2c%20using%20bit%20arrays%20for%20recommendations%2c%20caches%20and%20Bitcoin&amp;url=https%3a%2f%2fbart.degoe.de%2fbloom-filters-bit-arrays-recommendations-caches-bitcoin%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentColor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Bloom filters, using bit arrays for recommendations, caches and Bitcoin on ycombinator" href="https://news.ycombinator.com/submitlink?t=Bloom%20filters%2c%20using%20bit%20arrays%20for%20recommendations%2c%20caches%20and%20Bitcoin&u=https%3a%2f%2fbart.degoe.de%2fbloom-filters-bit-arrays-recommendations-caches-bitcoin%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentColor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2025 <a href=https://bart.degoe.de/>Bart de Goede</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>